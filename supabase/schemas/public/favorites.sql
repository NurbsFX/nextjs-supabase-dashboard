----------------------------------------------------------------
--                                                            --
--                      public.favorites                      --
--                                                            --
----------------------------------------------------------------

drop trigger if exists handle_updated_at on favorites;

drop function if exists set_favorite;

drop table if exists favorites;

----------------------------------------------------------------

create table favorites (
  id bigint generated by default as identity primary key,
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null,
  post_id bigint references posts(id) on delete cascade not null,
  user_id uuid references profiles(id) not null,
  is_favorite boolean default false not null,
  unique (user_id, post_id)
);

-- Secure the table
alter table favorites enable row level security;

-- Add row-level security
create policy "Public favorites are viewable by everyone." on favorites for select to authenticated, anon using ( true );
create policy "Users can insert their own favorite." on favorites for insert to authenticated with check ( (select auth.uid()) = user_id );
create policy "Users can update their own favorite." on favorites for update to authenticated using ( (select auth.uid()) = user_id );
create policy "Users can delete their own favorite." on favorites for delete to authenticated using ( (select auth.uid()) = user_id );

-- Update a column timestamp on every update.
create extension if not exists moddatetime schema extensions;

-- assuming the table name is "favorites", and a timestamp column "updated_at"
-- this trigger will set the "updated_at" column to the current timestamp for every update
create trigger handle_updated_at before update on favorites
  for each row execute procedure moddatetime (updated_at);

-- const { data, error } = await supabase.rpc('set_favorite', { postid: '', userid: '', isfavorite: '' });
-- select * from set_favorite('postid', 'userid', 'isfavorite');

create or replace function set_favorite(postid bigint, userid uuid, isfavorite boolean)
returns void
security definer set search_path = public
as $$
begin
  if exists (select 1 from favorites where post_id = postid and user_id = userid) then
    update favorites set is_favorite = isfavorite where post_id = postid and user_id = userid;
  else
    insert into favorites(post_id, user_id, is_favorite) values(postid, userid, isfavorite);
  end if;
end;
$$ language plpgsql;
